C51 COMPILER V9.60.0.0   IRRECEIVE                                                         08/13/2021 22:51:24 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE IRRECEIVE
OBJECT MODULE PLACED IN .\Objects\IrReceive.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE IrReceive.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Listings
                    -\IrReceive.lst) TABS(2) OBJECT(.\Objects\IrReceive.obj)

line level    source

   1          #include <REGX52.H>
   2          #include "IrReceive.h"
   3          
   4          unsigned char Time;
   5          unsigned char IrValue[6];
   6           
   7           /* 函数声明 ----------------------------------------------- */
   8           void Delay140us(unsigned int );  
   9                             
  10          /*******************************************************************************
  11          * 函数           : Delay140us()
  12          * 函数功能     : 延时
  13          * 输入           : x
  14          * 输出           : 无
  15          *******************************************************************************/
  16          
  17          void Delay140us(unsigned int x)   //0.14ms误差 0us
  18          {
  19   1        unsigned char i;
  20   1        while(x--)
  21   1        {
  22   2          for (i = 0; i<12; i++)
  23   2          {}
  24   2        }
  25   1      }
  26          /**********************************************************
  27           * 函数名称 : IR_Init()
  28           * 功    能 : 初始化红外线接收
  29           * 备    注 : 初始化外部中断1
  30           **********************************************************/
  31          void IR_Init()
  32          {
  33   1        IT1=1;   //下降沿触发
  34   1        EX1=1;   //打开中断0允许
  35   1        EA=1;  //打开总中断
  36   1        IRIN=1;  //初始化端口
  37   1      }
  38          
  39          /**********************************************************
  40           * 函数名称 : ReadIr()
  41           * 功    能 : 接受红外线信号并进行解码
  42           * 备    注 : 外部中断1中断函数
  43           ***********************************************************/
  44          void ReadIr() interrupt 2
  45          {
  46   1        unsigned char j,k;
  47   1        unsigned int err;
  48   1        Time=0;          
  49   1        Delay140us(60);
  50   1      
  51   1        if(IRIN==0)   //确认是否真的接收到正确的信号
  52   1        {  
  53   2          err=1000;       //1000*10us=10ms,超过说明接收到错误的信号
  54   2          /*当两个条件都为真是循环，如果有一个条件为假的时候跳出循环，免得程序出
C51 COMPILER V9.60.0.0   IRRECEIVE                                                         08/13/2021 22:51:24 PAGE 2   

             -错的时
  55   2          侯，程序死在这里*/  
  56   2          while((IRIN==0)&&(err>0)) //等待前面9ms的低电平过去     
  57   2          {     
  58   3            Delay140us(1);
  59   3            err--;
  60   3          } 
  61   2          if(IRIN==1)     //如果正确等到9ms低电平
  62   2          {
  63   3            err=500;
  64   3            while((IRIN==1)&&(err>0))    //等待4.5ms的起始高电平过去
  65   3            {
  66   4              Delay140us(1);
  67   4              err--;
  68   4            }
  69   3            for(k=0;k<4;k++)    //共有4组数据
  70   3            {       
  71   4              for(j=0;j<8;j++)  //接收一组数据
  72   4              {
  73   5      
  74   5                err=60;   
  75   5                while((IRIN==0)&&(err>0))//等待信号前面的560us低电平过去
  76   5                {
  77   6                  Delay140us(1);
  78   6                  err--;
  79   6                }
  80   5                err=500;
  81   5                while((IRIN==1)&&(err>0))  //计算高电平的时间长度。
  82   5                {
  83   6                  Delay140us(1);//0.14ms
  84   6                  Time++;
  85   6                  err--;
  86   6                  if(Time>30)
  87   6                  {
  88   7                    EX1=1;
  89   7                    return;
  90   7                  }
  91   6                }
  92   5                IrValue[k]>>=1;  //k表示第几组数据
  93   5                if(Time>=8)     //如果高电平出现大于565us，那么是1
  94   5                {
  95   6                  IrValue[k]|=0x80;
  96   6                }
  97   5                Time=0;   //用完时间要重新赋值             
  98   5              }
  99   4            }
 100   3          }
 101   2          if(IrValue[2]!=~IrValue[3])
 102   2          {
 103   3            return;
 104   3          }
 105   2          else if('E'==IrValue[2] || 'F'==IrValue[2] || 'G'==IrValue[2]){
 106   3            P1_2=1;
 107   3            IrValue[2]='0';
 108   3          }
 109   2          else if('D'==IrValue[2] || '@'==IrValue[2] || 'C'==IrValue[2]){
 110   3            P1_2=0;
 111   3            IrValue[2]='0';
 112   3          }
 113   2          
 114   2        } 
 115   1      }
C51 COMPILER V9.60.0.0   IRRECEIVE                                                         08/13/2021 22:51:24 PAGE 3   

 116          
 117          /**********************************************************
 118           * 函数名称 : IR_Get_KeyValue
 119           * 功    能 : 取得红外线信号中命令码
 120           * 输    出 : 命令码（键值）
 121          ********************************************************
 122          unsigned char IR_Get_KeyValue( void )
 123          {
 124            return IrValue[2];
 125          }
 126          
 127          void rm_KeyValue( void )
 128          {
 129            IrValue[6]=0;
 130          }
 131          ***/


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    362    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      7       1
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
